# API Endpoint Implementation Plan: POST /flashcards

## 1. Endpoint Overview

This endpoint creates a new flashcard in the system. It supports three types of flashcard creation:

1. **Manual creation** - User creates a flashcard from scratch
2. **AI-generated** - Flashcard created entirely by AI and saved directly
3. **AI-edited** - Flashcard initially generated by AI but modified by the user before saving

The endpoint initializes the flashcard with default SM-2 spaced repetition algorithm values (ease_factor: 2.5, interval_days: 0, repetition: 0) and optionally assigns it to a deck. When an AI-generated flashcard is accepted, an audit event is logged to track AI usage metrics.

---

## 2. Request Details

### HTTP Method

`POST`

### URL Structure

`/api/flashcards`

### Headers

- `Authorization: Bearer <jwt_token>` (Required)
- `Content-Type: application/json` (Required)

### Request Body

```typescript
{
  front: string;        // Required, 1-1000 characters
  back: string;         // Required, 1-1000 characters
  deckId?: string;      // Optional, valid UUID
  source?: 'AI' | 'MANUAL' | 'AI_EDITED';  // Optional, defaults to 'MANUAL'
}
```

### Example Request

```json
{
  "front": "What is the capital of France?",
  "back": "Paris",
  "deckId": "550e8400-e29b-41d4-a716-446655440000",
  "source": "MANUAL"
}
```

---

## 3. Used Types

### Request DTO

**CreateFlashcardRequest** (from `src/types.ts`)

```typescript
interface CreateFlashcardRequest {
  front: string;
  back: string;
  deckId?: string;
  source?: FlashcardSource;
}
```

### Response DTO

**FlashcardResponse** (from `src/types.ts`)

```typescript
interface FlashcardResponse {
  id: string;
  front: string;
  back: string;
  deckId: string | null;
  source: FlashcardSource;
  easeFactor: number;
  intervalDays: number;
  repetition: number;
  nextReviewAt: string | null;
  createdAt: string;
  updatedAt: string;
  userId: string;
  deletedAt: string | null;
}
```

### Supporting Types

**FlashcardSource** (from `src/types.ts`)

```typescript
type FlashcardSource = "AI" | "MANUAL" | "AI_EDITED";
```

### Validation Schema

**CreateFlashcardSchema** (to be created using Zod)

```typescript
import { z } from "zod";

const CreateFlashcardSchema = z.object({
  front: z.string().min(1, "Front text is required").max(1000, "Front text must not exceed 1000 characters").trim(),
  back: z.string().min(1, "Back text is required").max(1000, "Back text must not exceed 1000 characters").trim(),
  deckId: z.string().uuid("Invalid deck ID format").optional(),
  source: z.enum(["AI", "MANUAL", "AI_EDITED"]).default("MANUAL"),
});
```

---

## 4. Response Details

### Success Response (201 Created)

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "front": "What is the capital of France?",
  "back": "Paris",
  "deckId": "550e8400-e29b-41d4-a716-446655440000",
  "source": "MANUAL",
  "easeFactor": 2.5,
  "intervalDays": 0,
  "repetition": 0,
  "nextReviewAt": null,
  "createdAt": "2025-10-09T12:00:00.000Z",
  "updatedAt": "2025-10-09T12:00:00.000Z",
  "userId": "auth-user-id-here",
  "deletedAt": null
}
```

### Error Responses

#### 400 Bad Request

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": [
      {
        "field": "front",
        "message": "Front text is required"
      }
    ]
  }
}
```

#### 401 Unauthorized

```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Authentication required"
  }
}
```

#### 403 Forbidden

```json
{
  "error": {
    "code": "FORBIDDEN",
    "message": "You do not have permission to add cards to this deck"
  }
}
```

#### 404 Not Found

```json
{
  "error": {
    "code": "DECK_NOT_FOUND",
    "message": "The specified deck does not exist"
  }
}
```

#### 500 Internal Server Error

```json
{
  "error": {
    "code": "INTERNAL_ERROR",
    "message": "An unexpected error occurred while creating the flashcard"
  }
}
```

---

## 5. Data Flow

### Step-by-Step Flow

1. **Request Reception**
   - Astro API route receives POST request
   - Extract JWT token from Authorization header
   - Extract request body

2. **Input Validation**
   - Validate request body against Zod schema
   - If validation fails, collect all errors and return 400
   - Sanitize front/back text to prevent XSS

3. **Deck Ownership Verification** (if deckId provided)
   - Query `decks` table using Supabase client
   - Filter: `id = deckId AND user_id = auth.uid() AND deleted_at IS NULL`
   - If deck not found or doesn't belong to user:
     - Return 404 if deck doesn't exist
     - Return 403 if deck belongs to another user

4. **Flashcard Creation**
   - Insert new row into `flashcards` table with:
     - `id`: auto-generated UUID
     - `user_id`: from JWT token
     - `deck_id`: from request (nullable)
     - `front`: from request
     - `back`: from request
     - `source`: from request (default 'MANUAL')
     - `ease_factor`: 2.5 (default)
     - `interval_days`: 0 (default)
     - `repetition`: 0 (default)
     - `next_review_at`: NULL
     - `created_at`: now()
     - `updated_at`: now()
     - `deleted_at`: NULL

5. **Event Logging** (if source is 'AI')
   - Insert audit event into `events` table:
     - `user_id`: from JWT token
     - `flashcard_id`: newly created flashcard ID
     - `action`: 'ACCEPT'
     - `source`: 'AI'
     - `created_at`: now()

6. **Response Transformation**
   - Map database column names to camelCase DTO format
   - Format timestamps to ISO 8601
   - Return 201 with FlashcardResponse

### Database Interactions

```sql
-- 1. Verify deck ownership (if deckId provided)
SELECT id FROM decks
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL;

-- 2. Insert flashcard
INSERT INTO flashcards (
  user_id, deck_id, front, back, source,
  ease_factor, interval_days, repetition,
  next_review_at, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5,
  2.50, 0, 0,
  NULL, NOW(), NOW()
)
RETURNING *;

-- 3. Insert audit event (if source = 'AI')
INSERT INTO events (
  user_id, flashcard_id, action, source, created_at
) VALUES (
  $1, $2, 'ACCEPT', 'AI', NOW()
);
```

### Service Layer Structure

**File:** `src/lib/flashcard.service.ts`

```typescript
import type { SupabaseClient } from "./db/supabase.client";
import type { CreateFlashcardRequest, FlashcardResponse } from "./types";

export class FlashcardService {
  constructor(private supabase: SupabaseClient) {}

  async createFlashcard(userId: string, data: CreateFlashcardRequest): Promise<FlashcardResponse> {
    // Implementation here
  }

  private async verifyDeckOwnership(deckId: string, userId: string): Promise<boolean> {
    // Implementation here
  }

  private async logAcceptEvent(userId: string, flashcardId: string): Promise<void> {
    // Implementation here
  }

  private mapToResponse(dbRecord: any): FlashcardResponse {
    // Implementation here
  }
}
```

---

## 6. Security Considerations

### Input Sanitization

- **XSS Prevention**:
  - Sanitize `front` and `back` text fields
  - Strip HTML tags or encode special characters
  - Consider using DOMPurify or similar library
- **SQL Injection Prevention**:
  - Use Supabase client's parameterized queries (automatic)
  - Never concatenate user input into SQL strings

### Content Validation

- **Length Enforcement**: Strict validation of 1-1000 character limits
- **Enum Validation**: Only allow valid source values
- **UUID Validation**: Verify deckId is properly formatted UUID

### CORS

- Configure appropriate CORS headers if frontend is on different domain
- Restrict origins to trusted domains only

---

## 7. Error Handling

### Validation Errors (400)

**Scenarios:**

- Missing required field (front or back)
- Empty string after trimming
- Field exceeds 1000 characters
- Invalid UUID format for deckId
- Invalid source enum value

**Response:**

```typescript
{
  error: {
    code: 'VALIDATION_ERROR',
    message: 'Invalid input data',
    details: [
      { field: 'front', message: 'Front text is required' },
      { field: 'back', message: 'Back text must not exceed 1000 characters' }
    ]
  }
}
```

**Handling:**

- Catch Zod validation errors
- Transform into standardized error format
- Log validation failures (debug level)

### Authorization Errors (403)

**Scenarios:**

- User tries to add card to another user's deck

**Response:**

```typescript
{
  error: {
    code: 'FORBIDDEN',
    message: 'You do not have permission to add cards to this deck'
  }
}
```

**Handling:**

- Verify deck ownership before insertion
- Log unauthorized access attempts (warning level)

### Not Found Errors (404)

**Scenarios:**

- Specified deckId doesn't exist
- Deck is soft-deleted (deleted_at IS NOT NULL)

**Response:**

```typescript
{
  error: {
    code: 'DECK_NOT_FOUND',
    message: 'The specified deck does not exist'
  }
}
```

**Handling:**

- Check deck existence before flashcard creation
- Don't distinguish between non-existent and deleted decks (security)

### Server Errors (500)

**Scenarios:**

- Database connection failure
- Unexpected database error
- Service unavailable

**Response:**

```typescript
{
  error: {
    code: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred while creating the flashcard'
  }
}
```

**Handling:**

- Catch all unhandled exceptions
- Log full error details (error level) with stack trace
- Return generic message to client (don't expose internals)
- Consider implementing error monitoring (e.g., Sentry)

### Error Logging Strategy

```typescript
// Error severity levels
- DEBUG: Validation failures (user error)
- INFO: Successful operations
- WARNING: Authorization failures, suspicious activity
- ERROR: Database errors, service failures
- CRITICAL: System-wide failures

// Log format
{
  timestamp: '2025-10-09T12:00:00.000Z',
  level: 'ERROR',
  userId: 'user-id',
  endpoint: 'POST /api/flashcards',
  error: 'Database connection failed',
  stack: '...',
  requestId: 'unique-request-id'
}
```

---

## 8. Performance Considerations

### Database Optimization

1. **Index Usage**
   - Ensure index on `decks(id, user_id)` for ownership check
   - Use existing `flashcards(user_id)` index for insertion
   - Events table partition strategy handles write performance

2. **Query Optimization**
   - Deck verification query is indexed and fast (O(1) lookup)
   - Single INSERT for flashcard with RETURNING clause (1 round-trip)
   - Optional event logging doesn't block response

3. **Connection Pooling**
   - Supabase handles connection pooling automatically
   - No need for manual connection management

### Caching Strategy

**Not Recommended for This Endpoint:**

- POST operations should not be cached
- Each creation generates unique data
- Caching would provide no benefit

### Async Operations

**Event Logging:**

- Consider making event logging asynchronous
- Don't wait for event insert to complete before responding
- Use fire-and-forget pattern or message queue

**Implementation:**

```typescript
// Fire-and-forget event logging
if (source === "AI") {
  logAcceptEvent(userId, flashcardId).catch((err) => {
    console.error("Failed to log accept event:", err);
  });
}
```

### Potential Bottlenecks

1. **Deck Ownership Check**
   - **Impact**: Adds ~30ms when deckId provided
   - **Mitigation**: Ensure proper indexing, consider caching deck ownership for session

2. **Event Logging**
   - **Impact**: Adds ~30ms for AI-generated cards
   - **Mitigation**: Make asynchronous (fire-and-forget)

3. **Partitioned Events Table**
   - **Impact**: Partition routing overhead
   - **Mitigation**: PostgreSQL handles this efficiently; monitor partition performance

### Monitoring Metrics

**Key Performance Indicators:**

- Request duration (p50, p95, p99)
- Error rate by type
- Database query duration
- Rate limit hit rate
- Cards created per minute

**Alerting Thresholds:**

- Error rate > 5%
- p95 latency > 500ms
- Database query duration > 200ms

---

## 9. Implementation Steps

### Step 1: Create Validation Schema

**File:** `src/lib/validation/flashcard.validation.ts`

```typescript
import { z } from "zod";

export const CreateFlashcardSchema = z.object({
  front: z.string().min(1, "Front text is required").max(1000, "Front text must not exceed 1000 characters").trim(),
  back: z.string().min(1, "Back text is required").max(1000, "Back text must not exceed 1000 characters").trim(),
  deckId: z.string().uuid("Invalid deck ID format").optional(),
  source: z.enum(["AI", "MANUAL", "AI_EDITED"]).default("MANUAL"),
});
```

### Step 2: Create Flashcard Service

**File:** `src/lib/flashcard.service.ts`

Implement the following methods:

- `createFlashcard(userId: string, data: CreateFlashcardRequest): Promise<FlashcardResponse>`
- `verifyDeckOwnership(deckId: string, userId: string): Promise<boolean>`
- `logAcceptEvent(userId: string, flashcardId: string): Promise<void>`
- `mapToResponse(dbRecord: any): FlashcardResponse`

**Key implementation details:**

- Use `this.supabase` from constructor
- Handle all database errors with try-catch
- Use transactions if needed for data consistency
- Map snake_case DB fields to camelCase DTO fields

### Step 3: Create API Route Handler

**File:** `src/pages/api/flashcards.ts`

```typescript
import type { APIRoute } from "astro";
import { CreateFlashcardSchema } from "../../lib/validation/flashcard.validation";
import { FlashcardService } from "../../lib/flashcard.service";
import type { ApiErrorResponse, FlashcardResponse } from "../../types";

export const POST: APIRoute = async ({ request, locals }) => {
  try {
    // 1. Authentication check
    const user = locals.user;
    if (!user) {
      return new Response(
        JSON.stringify({
          error: {
            code: "UNAUTHORIZED",
            message: "Authentication required",
          },
        } as ApiErrorResponse),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }

    // 2. Parse and validate request body
    const body = await request.json();
    const validationResult = CreateFlashcardSchema.safeParse(body);

    if (!validationResult.success) {
      return new Response(
        JSON.stringify({
          error: {
            code: "VALIDATION_ERROR",
            message: "Invalid input data",
            details: validationResult.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message,
            })),
          },
        } as ApiErrorResponse),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    // 3. Create flashcard via service
    const flashcardService = new FlashcardService(locals.supabase);
    const flashcard = await flashcardService.createFlashcard(user.id, validationResult.data);

    // 4. Return success response
    return new Response(JSON.stringify(flashcard), {
      status: 201,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    // Handle specific error types
    // Return appropriate error response
  }
};
```

### Step 4: Implement Service Layer Logic

**In `FlashcardService.createFlashcard`:**

1. If deckId provided, verify deck ownership:

   ```typescript
   if (data.deckId) {
     const hasAccess = await this.verifyDeckOwnership(data.deckId, userId);
     if (!hasAccess) {
       throw new ForbiddenError("You do not have permission to add cards to this deck");
     }
   }
   ```

2. Insert flashcard into database:

   ```typescript
   const { data: flashcard, error } = await this.supabase
     .from("flashcards")
     .insert({
       user_id: userId,
       deck_id: data.deckId || null,
       front: data.front,
       back: data.back,
       source: data.source,
       ease_factor: 2.5,
       interval_days: 0,
       repetition: 0,
       next_review_at: null,
     })
     .select()
     .single();

   if (error) throw error;
   ```

3. Log accept event if source is 'AI':

   ```typescript
   if (data.source === "AI") {
     await this.logAcceptEvent(userId, flashcard.id);
   }
   ```

4. Transform and return response:
   ```typescript
   return this.mapToResponse(flashcard);
   ```

### Step 5: Implement Deck Ownership Verification

```typescript
private async verifyDeckOwnership(
  deckId: string,
  userId: string
): Promise<boolean> {
  const { data, error } = await this.supabase
    .from('decks')
    .select('id')
    .eq('id', deckId)
    .eq('user_id', userId)
    .is('deleted_at', null)
    .single();

  if (error || !data) {
    return false;
  }

  return true;
}
```

### Step 6: Implement Event Logging

```typescript
private async logAcceptEvent(
  userId: string,
  flashcardId: string
): Promise<void> {
  try {
    const { error } = await this.supabase
      .from('events')
      .insert({
        user_id: userId,
        flashcard_id: flashcardId,
        action: 'ACCEPT',
        source: 'AI'
      });

    if (error) {
      console.error('Failed to log accept event:', error);
    }
  } catch (err) {
    // Don't throw - event logging is non-critical
    console.error('Unexpected error logging event:', err);
  }
}
```

### Step 7: Implement Response Mapper

```typescript
private mapToResponse(dbRecord: any): FlashcardResponse {
  return {
    id: dbRecord.id,
    front: dbRecord.front,
    back: dbRecord.back,
    deckId: dbRecord.deck_id,
    source: dbRecord.source,
    easeFactor: parseFloat(dbRecord.ease_factor),
    intervalDays: dbRecord.interval_days,
    repetition: dbRecord.repetition,
    nextReviewAt: dbRecord.next_review_at,
    createdAt: dbRecord.created_at,
    updatedAt: dbRecord.updated_at,
    userId: dbRecord.user_id,
    deletedAt: dbRecord.deleted_at
  };
}
```

### Step 8: Add Error Handling

Create custom error classes:

**File:** `src/lib/errors.ts`

```typescript
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

export class ForbiddenError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ForbiddenError";
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public details: any[]
  ) {
    super(message);
    this.name = "ValidationError";
  }
}
```

Add error handling in API route:

```typescript
catch (error) {
  if (error instanceof ForbiddenError) {
    return new Response(
      JSON.stringify({
        error: {
          code: 'FORBIDDEN',
          message: error.message
        }
      }),
      { status: 403, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // ... handle other error types

  // Default 500 error
  console.error('Unexpected error:', error);
  return new Response(
    JSON.stringify({
      error: {
        code: 'INTERNAL_ERROR',
        message: 'An unexpected error occurred'
      }
    }),
    { status: 500, headers: { 'Content-Type': 'application/json' } }
  );
}
```

### Step 9: Update Middleware (if needed)

Ensure `src/middleware/index.ts` provides:

- Supabase client in `context.locals.supabase`

### Step 11: Update API Documentation

Update project documentation with:

- Endpoint description
- Request/response examples
- Error codes and meanings

---
